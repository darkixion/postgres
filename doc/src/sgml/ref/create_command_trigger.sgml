<!--
doc/src/sgml/ref/create_trigger.sgml
PostgreSQL documentation
-->

<refentry id="SQL-CREATECOMMANDTRIGGER">
 <refmeta>
  <refentrytitle>CREATE COMMAND TRIGGER</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE COMMAND TRIGGER</refname>
  <refpurpose>define a new trigger</refpurpose>
 </refnamediv>

 <indexterm zone="sql-createcommandtrigger">
  <primary>CREATE COMMAND TRIGGER</primary>
 </indexterm>

 <refsynopsisdiv>
<synopsis>
CREATE COMMAND TRIGGER <replaceable class="PARAMETER">name</replaceable> { BEFORE | AFTER  } ANY COMMAND
    EXECUTE PROCEDURE <replaceable class="PARAMETER">function_name</replaceable> ()

CREATE COMMAND TRIGGER <replaceable class="PARAMETER">name</replaceable> { BEFORE | AFTER  } <replaceable class="PARAMETER">command</replaceable>
    EXECUTE PROCEDURE <replaceable class="PARAMETER">function_name</replaceable> ()

<phrase>where <replaceable class="parameter">command</replaceable> can be one of:</phrase>

    ALTER AGGREGATE
    ALTER COLLATION
    ALTER CONVERSION
    ALTER DOMAIN
    ALTER EXTENSION
    ALTER FOREIGN DATA WRAPPER
    ALTER FOREIGN TABLE
    ALTER FUNCTION
    ALTER LANGUAGE
    ALTER OPERATOR
    ALTER OPERATOR CLASS
    ALTER OPERATOR FAMILY
    ALTER SCHEMA
    ALTER SEQUENCE
    ALTER SERVER
    ALTER TABLE
    ALTER TEXT SEARCH CONFIGURATION
    ALTER TEXT SEARCH DICTIONARY
    ALTER TEXT SEARCH PARSER
    ALTER TEXT SEARCH TEMPLATE
    ALTER TRIGGER
    ALTER TYPE
    ALTER USER MAPPING
    ALTER VIEW
    CLUSTER
    CREATE AGGREGATE
    CREATE CAST
    CREATE COLLATION
    CREATE CONVERSION
    CREATE DOMAIN
    CREATE EXTENSION
    CREATE FOREIGN DATA WRAPPER
    CREATE FOREIGN TABLE
    CREATE FUNCTION
    CREATE INDEX
    CREATE LANGUAGE
    CREATE OPERATOR
    CREATE OPERATOR CLASS
    CREATE OPERATOR FAMILY
    CREATE RULE
    CREATE SCHEMA
    CREATE SEQUENCE
    CREATE SERVER
    CREATE TABLE
    CREATE TEXT SEARCH CONFIGURATION
    CREATE TEXT SEARCH DICTIONARY
    CREATE TEXT SEARCH PARSER
    CREATE TEXT SEARCH TEMPLATE
    CREATE TRIGGER
    CREATE TYPE
    CREATE USER MAPPING
    CREATE VIEW
    DROP AGGREGATE
    DROP CAST
    DROP COLLATION
    DROP CONVERSION
    DROP DOMAIN
    DROP EXTENSION
    DROP FOREIGN DATA WRAPPER
    DROP FOREIGN TABLE
    DROP FUNCTION
    DROP INDEX
    DROP LANGUAGE
    DROP OPERATOR
    DROP OPERATOR CLASS
    DROP OPERATOR FAMILY
    DROP RULE
    DROP SCHEMA
    DROP SEQUENCE
    DROP SERVER
    DROP TABLE
    DROP TEXT SEARCH CONFIGURATION
    DROP TEXT SEARCH DICTIONARY
    DROP TEXT SEARCH PARSER
    DROP TEXT SEARCH TEMPLATE
    DROP TRIGGER
    DROP TYPE
    DROP USER MAPPING
    DROP VIEW
    LOAD
    REINDEX
    VACUUM

</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <command>CREATE COMMAND TRIGGER</command> creates a new command trigger.
   The trigger will be associated with the specified command and will
   execute the specified
   function <replaceable class="parameter">function_name</replaceable> when
   that command is run.
  </para>

  <para>
   The command trigger can be specified to fire before or after the command
   is executed. A command trigger's function must return <literal>command
   trigger</literal>. It can then only abort the execution of the command by
   raising an exception.
  </para>

  <para>
   If multiple triggers of the same kind are defined for the same event,
   they will be fired in alphabetical order by name.
  </para>

  <para>
   Note that objects dropped by the effect of <literal>DROP
   CASCADE</literal> will not result in a command trigger firing, only the
   top-level command for the main object will fire a command trigger. That
   also applies to other dependencies following, as in <literal>DROP OWNED
   BY</literal>.
  </para>

  <para>
   Refer to <xref linkend="triggers"> for more information about triggers.
  </para>
 </refsect1>

 <refsect1>
  <title>Parameters</title>

  <variablelist>
   <varlistentry>
    <term><replaceable class="parameter">name</replaceable></term>
    <listitem>
     <para>
      The name to give the new trigger. This must be distinct from the name
      of any other trigger for the same table. The name cannot be
      schema-qualified.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>BEFORE</literal></term>
    <term><literal>AFTER</literal></term>
    <listitem>
     <para>
      Determines whether the function is called before or after the command
      is executed.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">command</replaceable></term>
    <listitem>
     <para>
      The tag of the command the trigger is for. Supported commands are
      mainly those acting on database objects, plus some more facilities.
      That leaves out the following list of non supported commands.
     </para>
     <para>
      Commands that refer to global objects, such as databases, tablespaces
      and roles, are not supported.
     </para>
     <para>
      Commands that exercise their own transaction control are only
      supported in <literal>BEFORE</literal> command triggers.  This is the
      case for <literal>VACUUM</literal>, <literal>CLUSTER</literal>,
      <literal>CREATE INDEX CONCURRENTLY</literal>, and <literal>REINDEX
      DATABASE</literal>.
     </para>
     <para>
      The command <literal>ALTER TYPE ... ADD VALUE ...</literal> prevents
      transaction control entirely, thus no command trigger will get fired
      when it's used.
     </para>
     <para>
      Commands that are related to transaction control (such
      as <literal>BEGIN</literal> or <literal>COMMIT</literal>), related to
      prepared plans
      (e.g. <literal>PREPARE</literal>, <literal>DEALLOCATE</literal>),
      cursors management
      (e.g. <literal>DECLARE</literal>, <literal>FETCH</literal>), setting
      variables (<literal>SET</literal>), the <literal>LISTEN</literal>
      feature, and security are not supported either.
     </para>
     <para>
      Command triggers on <literal>CREATE COMMAND
      TRIGGER</literal>, <literal>ALTER COMMAND TRIGGER</literal>
      and <literal>DROP COMMAND TRIGGER</literal> are not supported so as
      not to be able to take over control from a superuser.
     </para>
     <para>
      Triggers on <literal>ANY</literal> command support more commands than
      just this list, and will only provide the <literal>command
      tag</literal> argument as <literal>NOT NULL</literal>. Supporting more
      commands is made so that you can actually block <xref linkend="ddl">
      commands in one go.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">function_name</replaceable></term>
    <listitem>
     <para>
      A user-supplied function that is declared as taking no argument and
      returning type <literal>command trigger</literal>.
     </para>
     <para>
      If your command trigger is implemented in <literal>C</literal> then it
      will be called with an argument, of
      type <literal>internal</literal>, which is a pointer to
      the <literal>Node *</literal> parse tree.
     </para>
    </listitem>
   </varlistentry>

  </variablelist>
 </refsect1>

 <refsect1 id="SQL-CREATECOMMANDTRIGGER-notes">
  <title>Notes</title>

  <para>
   To create a trigger on a command, the user must be superuser.
  </para>

  <para>
   Use <xref linkend="sql-dropcommandtrigger"> to remove a command trigger.
  </para>
 </refsect1>

 <refsect1 id="SQL-CREATECOMMANDTRIGGER-examples">
  <title>Examples</title>

  <para>
   Forbids the execution of any DDL command:

<programlisting>
CREATE OR REPLACE FUNCTION abort_any_command()
 RETURNS command trigger LANGUAGE plpgsql AS $$
BEGIN
  RAISE EXCEPTION 'command % is disabled', tg_tag;
END;
$$;

CREATE COMMAND TRIGGER abort_ddl
        BEFORE ANY COMMAND
       EXECUTE PROCEDURE abort_any_command();
</programlisting>

   Execute the function <function>enforce_local_style</> each time
   a <literal>CREATE TABLE</literal> command is run:

<programlisting>
CREATE OR REPLACE FUNCTION enforce_local_style()
 RETURNS command trigger LANGUAGE plpgsql AS $$
BEGIN
  IF substring(tg_objectname, 0, 4) NOT IN ('ab_', 'cz_', 'fr_')
  THEN
    RAISE EXCEPTION 'invalid relation name: %', tg_objectname;
  END IF;
END;
$$;

CREATE COMMAND TRIGGER check_style
        BEFORE CREATE TABLE
       EXECUTE PROCEDURE enforce_local_style();
</programlisting>
  </para>
 </refsect1>

 <refsect1 id="SQL-CREATECOMMANDTRIGGER-compatibility">
  <title>Compatibility</title>

  <para>
   <command>CREATE COMMAND TRIGGER</command> is a
   <productname>PostgreSQL</productname> extension of the <acronym>SQL</>
   standard.
  </para>

 </refsect1>

 <refsect1>
  <title>See Also</title>

  <simplelist type="inline">
   <member><xref linkend="sql-createfunction"></member>
   <member><xref linkend="sql-altercommandtrigger"></member>
   <member><xref linkend="sql-dropcommandtrigger"></member>
  </simplelist>
 </refsect1>
</refentry>
